[


  {
    "title": "Learning DSA",
    "url": "/blog/2025/10/03/learning-dsa/",
    "date": "2025-10-03",
    "tags": ["cs","dsa","data-structures"],
    "content": "Am I too old to learn DSA? I dont know, been programming for a while and I feel like I just know the basics, would really like to master this topic, find it interesting and its an underlying foundation for a lot of stuff used daily. Tried to half LLM a learning plan to be somewhat competent w/ DSA, I plan to do one post with every phase or chapter, depending how long it takes and go from there, hopefully you can learn something. Each chapter contains: Core concepts (what to learn) Resources (videos, articles, books) Practice (LeetCode problems) Goal (what you should master that) Should structure the learning by making a post per chater or phase not sure. Additional disclaimer, ignore the problems and its #, I just added leetcode because I know the website but this might change in the future and probably will add a link to every problem I do. Phase 1: Core Data Structures Chapter 1: Arrays &amp; Strings Concepts: indexing, iteration, two pointers, sliding window, prefix/suffix sums. Resources: Neetcode Arrays &amp; Hashing LeetCode Array &amp; String Explore CLRS, Ch. 2 (Getting Started) Goal: confidently apply sliding window and two-pointer patterns. Chapter 2: Hashing (Sets &amp; Maps) Concepts: hashmaps, sets, frequency counting, collisions, when to trade space for time. Resources: Neetcode Hashing Hashing article (GeeksforGeeks) CLRS, Ch. 11 (Hash Tables) Goal: solve grouping, frequency, and uniqueness problems with hashing. Chapter 3: Linked Lists, Stacks, Queues Concepts: pointers, reversal, cycle detection, monotonic stack, BFS with queue. Resources: Neetcode Linked List Neetcode Stack Neetcode Queue LeetCode Linked List Explore CLRS, Ch. 10 (Elementary Data Structures) Goal: quickly implement stack/queue logic, spot monotonic stack problems. Phase 2: Trees &amp; Graphs Chapter 4: Binary Trees Concepts: recursion, traversals (pre/in/post-order), height, diameter, LCA. Resources: Neetcode Trees LeetCode Tree Explore CLRS, Ch. 12 (Binary Search Trees) Goal: reduce problems into recursive traversals. Chapter 5: BSTs &amp; Heaps Concepts: BST invariants, balanced BSTs, min-heap/max-heap, priority queues. Resources: Neetcode BST Neetcode Heap CLRS, Ch. 6 (Heapsort) Goal: recognize when to use heap for “top-k” and scheduling problems. Chapter 6: Graph Traversals Concepts: adjacency list/matrix, BFS, DFS, connected components, topological sort. Resources: Neetcode Graphs LeetCode Graph Explore CLRS, Ch. 22 (Graph Algorithms) Goal: map graph problems to BFS/DFS patterns. Chapter 7: Shortest Paths &amp; Union-Find Concepts: Dijkstra, Bellman-Ford, Kruskal/Prim MST, disjoint sets (union-find). Resources: Neetcode Dijkstra Union-Find (GeeksforGeeks) CLRS, Ch. 23–24 (MST &amp; Shortest Paths) Goal: solve weighted graphs &amp; connectivity efficiently. Phase 3: Sorting &amp; Searching Chapter 8: Sorting Concepts: merge sort, quicksort, heap sort, interval scheduling, greedy sort. Resources: Neetcode Sorting CLRS, Ch. 7 (Quicksort) Goal: identify sorting as preprocessing step. Chapter 9: Binary Search Concepts: binary search patterns, lower/upper bound, search-on-answer. Resources: Neetcode Binary Search LeetCode Binary Search Explore Goal: master binary search variants. Phase 4: Dynamic Programming Chapter 10: 1D DP Concepts: recursion → memoization → tabulation. Resources: Neetcode DP Intro Chapter 11: 2D DP Concepts: grids, subsequences, edit distance. Resources: Neetcode 2D DP Chapter 12: Knapsack &amp; Variants Resources: CLRS, Ch. 15 (Dynamic Programming) Chapter 13: State Compression Chapter 14: Mixed Hard DP Practice: hard DP problems from LeetCode Goal: reduce recursion → memoization → tabulation; solve any DP-tagged LC problem. Phase 5: Advanced Topics Greedy: 55, 45, 135 Backtracking: 78, 46, 51 Segment Trees / Fenwick Trees: 307, 315 Strings (KMP, Trie): 208, 211, 14, 28 Bit Manipulation: 136, 191, 338 Learn workflow Theory (1–2h): watch videos, skim article/book chapter. Notes (30m): write definitions, time complexities, patterns. Practice (5–10 problems): solve progressively harder LC. Reflection (15m): tag problem → data structure/algorithm used. Endgame Build a mental classifier: given a problem, know immediately → “Graph BFS,” “Heap top-k,” “DP table,” etc. Write concise, clean code. Compete at LeetCode contest level, but with deep DS/Algo knowledge."
  },

  {
    "title": "Setting up Nvim for Python",
    "url": "/blog/2025/09/28/setting-up-nvim-for-python/",
    "date": "2025-09-28",
    "tags": ["python","neovim","lua"],
    "content": "Disclaimer by no means I am a Neovim expert and might not fully understand all of the internals of the tools I am going to talk about, this is just me learning by setting up a Nvim installation for Python. I have used nvim in the past, I use it often (like writing this blog) but when coding I still use vscode as it has a few features that I find useful such as the UI for tests, environment/run configurations and debugging. Regardless, I use the nvim extension for the motions in VSCode. I think Neovim, besides making you very efficient using the keyboard, its kind of a game, while you code. I’d recommend everyone trying to learn it, there’s plenty of resources and people in the additional resources sections from people who knows a lot and have great tutorials. Introduction Neovim (an extension of another text editor, vim) is a relatively simple (by default) text editor that is thought to be used mostly just using the keyboard. Over the time it has gained popularity as it allows (with time and practice) for incredible efficiency to code. If its so good why is not that popular though? Well it has a kind of learning curve, it can be somewhat hard to maintain (when you extend functionalities with plugins). I really recommend that if you come across this post and have not tried yet, give it a shot and jump directly to any tutorial and if you decide to embrace the journey you will find yourself creating something very personal, your own config that allows you to be very effective when navigating and working with code. Installation This is a guide on how to install Neovim on a MacOS M3, but it should work pretty much on any Linux distro. You could just copy in your terminal: brew install neovim ripgrep fd The first package neovim is quite self explanaotry, and then ripgrep and fd are improvements of grep and find, respectively, that are faster. The first one is to find text in files and the second one is to find files (if you are not familiar with those two commons I would recommend googling a little bit around). If you run then in your terminal nvim you should be greeted by a very simple window: And this would be the simplest version of Neovim, if you run neovim test.txt this will create a file (will not be saved by default) where you could start writing, but lets start for one of the hardest parts in Neovim; how to close it? First press esc to make sure you are in normal mode and then: :q -&gt; Will quit if there are no unsaved changes. :q! -&gt; Force quit, without saving. :wq or :x -&gt; save and quit. ZZ -&gt; write and quit. Note that there are several ways more, but those are the ones I have used over time, note that for the ones starting with semicolon : is that it will show at the bottom right the editor the characters you enter and then just press enter when you are done. In order to open neovim in an existing directory you can just go nvim (path) which I usally cd in to the project and write nvim .. Moving forward We are moving now a leap forward and assuming you are familiar with neovim modes and concepts such as buffers, windows, tabs… And jumping directly to TJ DeVries video - The Only Video You need to Get Started With Neovim. It basically lets you set up a pretty complete set up using kickstart.nvim and ge you started, it is very important that you watch the video and google a little bit around, play around with the :Tutor and watch a few videos. If you ever feel stuck or feel like a feature is missing as we progress in this post, investigate and see how feasible is to implemenet it (it probably is, the question is how hard). Setting up a Python Nvim installation Using Lazy its quite easy, we are looking for the following features in our IDE: Linter: We use ruff from astral. Typing: We use ty from astral. Support for testing. Support for debugging. Manage virtual environments Linter and typing We will be tackling those two at once given that they are kinda related, one is going to make our code look pretty and the other make sure the types in our code match the signature of our methods. This should be quite easy and wherever we are declaring all of our plugins using Lazy, you should look something like require('lazy').setup in your code, in the server table: ruff = { on_attach = function(c) c.server_capabilities.hoverProvider = false -- ty takes over hover end, }, ty = {}, This will just make sure that both ruff and ty are set up in our LSP, we just set the hover priority over ty for types rather than ruff. Other than that you can find the lsp configurations for each of the plugins and see all the options that can be passed. Really the work of ruff is mostly automatic and it will basically format on save or when pressing leader+f. For ty we will be getting warnings whenever, for example, there is a type missmatch: Testing For testing I really wanted a visual way to understand how the tests are doing and the output of the testing incase it fails, this really comes out of the box for neotest and neotest-python, for example with such a dummy test files if we just push leader+t+f as per test file we can see the status of the tests on the left: Also you can do test summary with leader+t+s to see this fancy tab (see the pattern of leader+keystrokes that match our intention?): Debugging Debugging is critical, very similar, at any point in code if we push leader+d+b it toggles a breakpoint, see the small B on the left: Then if we just launch a session leader+d+c and it will stop and you will be able to explore the entire debug session: Virtual Environment Quite simple, pressing leader+c+v will prompt you for which venv to use: Going forward This was just a simple guide of someone who is kinda familiar with Neovim, if you decide to reuse the init.lua I have on my repo –TODO add link, I also recommend checking on snippets the neovim one to get familiar with the commands. I probably also need to post a second part talking about oil, but please try Neovim and have the cheathseet opened in another tab to have quick access to the commands. Again, Neovim can be hard at the beginning, the set up and the motions but I encourage you to give it a shot, if you come from VSCode enable vim mode there and try to use neovim later on directly. Additional resources Neovim official page Teej Dv Youtube chanel Telescope nvim"
  },

  {
    "title": "Starting a blog",
    "url": "/blog/2025/09/23/setting-this-up/",
    "date": "2025-09-23",
    "tags": ["jekyll","github","git","docker","html","css"],
    "content": "Starting a blog In this, more than ever, fast changing times in tech I decided to set up a blog. I am not sure what will come out of this other than me writing down stuff and trying to explain what I learn. TL;DR Use GitHub Pages + Jekyll for a simple, free blog Create posts under _posts/ with YYYY-MM-DD-title.md Add a blog index page and optional /blog/ permalinks Run locally with Docker for faster iteration Contents Introduction After looking around seems like github pages might be the best resource, like its simplicity and I dont like this kind of monetized-paywalls like medium and so on. The list of resources I used so far is: Creating an Engineering Blog with GitHub Pages. Creating and Hosting a Personal Site on GitHub. Build A Blog With Jekyll And Github Pages This assumes you are qutie familiar already with tools like Git, Github and can understand some basic web development cocnepts using HTML/CSS/Javascript. Git &amp; Github Git is an OSS tool to keep track of the state of a file (VCS, Version Control System) and understand all of its transformations over time, making it easy to jump back and forth between those (think of those university projects that kept getting created project.doc, then project_v2.doc, project_v2_final.doc, but you dont need to create multiple files and can jump back and forth somewhat easily). It is a very powerful tool, it can really do a lot of things and I probably only use around 5% of its commands but you can find more information in Git’s page. Github is a service that (among other things) offers you to host those projects online, so makes it easy to collaborate with other people online (happens a lot in software), there are similar platforms also such as Gitlab. Although all of those Git + whatever might be confusing, the distinction between the actual technology(Git) and the platforms (Github, Gitlab) offering its services its important, and you need to beceome somewhat familiar with it over your career. Github pages Github pages are a way to create a free website (or subdomain) in their page, its quite tech oriented (given that Github is a tech company) and easy to set up. My personal thoughts on why its great: Free. You will get familiar with git. Simple Creating the blog The first step is quite easy, assuming you have a github account just create a new repository with yourusername.github.io, visibility public and I recommend marking the option add README. After creating it update a file index.html on the root folder of the repository (hint, if you don’t know git at this point would be great if you pause and learn how to pull a repository locally, add files and upload(push) them, or the least recommended option is to use the UI). The file could be as simple as: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;Hello World&lt;/head&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;/html&gt; Now going to yourusername.github.io should show a very simple ugly page welcoming you. Here is where you can get some insipration going on and feel free to use HTML, CSS to make it look fancier (see Additional resources), we will just be covering some very basics below. Getting fancy We will be adding some Cascading Style Sheet (CSS) which can be understood as a way to define styles for HTML documents, modifying fonts, size, color of HTML elements. In order to avoid having all of our files lying around we will be creating a specific folder for storing our css files and create our first file under css/main.css, which will look like: body { background-color: \"#F0F8FF\"; } h1 { font-family: 'Comic Sans MS'; } Now after having this file uploaded (pushed) to your repository, if you wait a little and refresh your page things should look slightly different. You can really get some cool stuff done with just HTML/CSS so I’d recommend you playing a little bit around before if you are not familiar yet. Jekyll Jekyll is a new tech for me, so we will be learning together. It seems to be a way to go from plainetxt to some cool websites and blogs, so we are just going to set up some structure in our repository (folder where our website conents are) and it will automatically pick it up and save us some time. It fits very well with Github pages simplicty where we can just upload the files directly and no need of a database. One of the advantages is using templates (layouts) so you can save some time avoiding some repetitive tasks, the folder structure is defined here, I will kinda speed run this but the link to Creating and Hosting a Personal Site on GitHub in the introduction explains it with more details. An important file is the ._config.yml, I recommend checking the official docs here and also its defaults values, as you explore the tool and feel you are missing something go and explore if its already implemented. lsi: true safe: true gist: noscript: false kramdown: math_engine: mathjax syntax_highlighter: rouge The next step is creating the _layouts folder, where we will create a default.html which will be added on every post, so it makes sense for us to define a header and a footer (HTML tags). The cool thing of the layouts is you can reference then them anywhere from another html file, so we can do the following on our index.html file: --- layout: default title: This is the first attempt --- &lt;div&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;/div&gt; Notice at the top of the file? Yhose are called Front-matter in Jekyll and this means every file starting with those characters will be processed by the framework, and basically we are just calling it to use our layouts/_default to craete a new HTML page where the content will be replaced in the ``. The blog itself Jekyll has a lot out of the box features to create a blog and allows for customization but the tutorials that we followed will cover the basics to creat a post, a page to index our posts, creating permalinks for our posts and finally RRS feed. To creat a post layout we go back to layouts and create a post.html file, something as simple as: --- layout: default --- &lt;h1&gt; Starting a blog &lt;/h1&gt; &lt;p class=\"meta\"&gt;Written the 23 Sep 2025&lt;/p&gt; &lt;div class=\"post\"&gt; &lt;/div&gt; We need to create a directory posts where we will store our posts _posts/ and now its important we are very strict with the name of the files under and follow the convention as YYYY-MM-DD-title-of-post.md, so we can do something like 2025-09-21-first-post.mdwith the content: --- layout: post title: \"We try our first post\" date: 2025-21-09 --- This is where we try our first post following mostly jmcglone's tutorial Notice some of the elements between ---, like title or date, those should be familiar with our post.html template. If everything went fine (e.g I missed up and forgot the _ before the posts directory), you should be able to see your post in YYYY-MM-DD-title-of-my-post.html, great! But having to remember all of this is quite annoying so let’s first build a page where we canlist all of our post and just click to access them. In order to do so, we need an additional directory named blog, where we are adding the following html file (note that this is not “pure” (whatever this means) HTML it self, it contains some templating), in this case we are going to loop for all the files under our post directory and list them in the file index.html (under blog dir): --- layout: default title: AlejandroUPC's Blog --- &lt;h1&gt;{{ page.title }}&lt;/h1&gt; &lt;ul class=\"posts\"&gt; {% for post in site.posts %} &lt;li&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &lt;a href=\"{{ post.url }}\" title=\"{{ post.title }}\"&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt; {% endfor %} &lt;/ul&gt; Now if you just access your page and add /blog at the end you should see at least one post that we just created earlier! You probably have seen the post links do not contain the /blog directory under the URL, this might or not be relevant to you but it might make sense to change the way the URLs are built under posts to include it, you can go back to your _config.yml file and add this to modify how the permalinks are created: permalink: /blog/:year/:month/:day/:title Now you should be able to access your posts as http://username.github.io/blog/YYYY/MM/DD/name-of-your-post.. Finally one of the last steps could be to set up a RSS feed for your blog, this is quite easy and you simply create a file named atom.xml under the blog/ dir. --- layout: feed --- &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;feed xmlns=\"http://www.w3.org/2005/Atom\"&gt; &lt;title&gt;Hank Quinlan's Blog&lt;/title&gt; &lt;link href=\"http://alejandroupc.github.io/blog/atom.xml\" rel=\"self\"/&gt; &lt;link href=\"http://alejandroupc.github.io/blog\"/&gt; &lt;updated&gt;{{ site.time | date_to_xmlschema }}&lt;/updated&gt; &lt;id&gt;http://alejandroupc.github.io/blog&lt;/id&gt; &lt;author&gt; &lt;name&gt;AlejandroUPC&lt;/name&gt; &lt;email&gt;amartinezotal@gmail.com&lt;/email&gt; &lt;/author&gt; {% for post in site.posts %} &lt;entry&gt; &lt;title&gt;{{ post.title }}&lt;/title&gt; &lt;link href=\"http://alejandroupc.github.io{{ post.url }}\"/&gt; &lt;updated&gt;{{ post.date | date_to_xmlschema }}&lt;/updated&gt; &lt;id&gt;http://alejandroupc.github.io{{ post.id }}&lt;/id&gt; &lt;content type=\"html\"&gt;{{ post.content | xml_escape }}&lt;/content&gt; &lt;/entry&gt; {% endfor %} &lt;/feed&gt; So that’s it pretty much, now you can add posts to your blog, add it to RSS and share it with whoever (As Jmcglone recommends do not ofroget to create the about/index.html and cv/index.html pages for the links we added before in our header/footer) Setting up a local environment All of this setup is cool, but in order to see the results we need to commit our code, github runs some steps in the background (a pipeline) and then publishes it to “the internet”, there might be a few things that can be improved here: The feedback loop feels slow, maybe we could see what it looks like before it reaches the internet and review for typos, format issues, etc … We might break something from Jekyll and the pipeline will fail, changes will not show, we will have to keep committing until fixed and this can be tedious. We might want to test also stuff before uploading it. This where Docker comes into play, which is a tool that allows you to containerize software and run it into isolated environments. Basically if you are not very familiar what we are going to try to do is follow the same steps that Github does in their own pipeline and be able to see the website in our computer before pushing the changes. From here we assume you are familiar with Docker enough to deploy and run containers locally, you can set up the following Dockerfile: FROM ruby:3.1-slim ENV LANG=C.UTF-8 \\ LC_ALL=C.UTF-8 \\ DEBIAN_FRONTEND=noninteractive RUN apt-get update &amp;&amp; apt-get install -y \\ build-essential \\ git \\ curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/* WORKDIR /usr/src/app COPY Gemfile* ./ RUN gem install bundler &amp;&amp; bundle install COPY . . EXPOSE 4000 CMD [\"bundle\", \"exec\", \"jekyll\", \"serve\", \"--host\", \"0.0.0.0\", \"--watch\"] We will need to create a Gemfile (what is a Gemfile) with this content: source \"https://rubygems.org\" gem \"jekyll\" group :jekyll_plugins do gem \"jekyll-feed\" gem \"jekyll-seo-tag\" end And finally run the command docker run --rm -p 4000:4000 -v \"$PWD\":/usr/src/app jekyll-site Now you should be able to go to http://localhost:4000/blog and you should be able to see the same as will be later on your site in github. Closing This is the process I used to set up this blog, which leaves it in a quite basic state. If any improvements there will probably in a future entry. The process (if familiar with the tech stack involved) is quite straight forward and the authors of the articles I used (and linked) did an amazing job. Additional resources Git documentation HTML CSS Mozilla Docs Jekyll Docker Dockerize your Jekyll site"
  },

  {
    "title": "Python split: using maxsplit",
    "url": "/snippets/python-maxsplit/",
    "date": "2025-09-25",
    "tags": ["python","tips"],
    "content": "Using maxsplit for str.split Was working on an issue where we were at some point in a service were generating an identifier of the form foo-bar, where foo could be our internal identifier and bar an external identifier. In the code at some point we needed to split those two, and the code that was working was: key = 'foo-bar' id_one, id_two = key.split(\"-\") Which worked just well, but the issue is that at some point we got foo-bar-xyz and as you’d expect an unpack error was raised: &gt;&gt;&gt; id_one, id_two = key.split(\"-\") Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; ValueError: too many values to unpack (expected 2) What was my initial solution? This: &gt;&gt;&gt; id_one, id_two = key.split(\"-\")[0], \"-\".join(str(x) for x in key.split(\"-\")[1:]) &gt;&gt;&gt; id_one 'foo' &gt;&gt;&gt; id_two 'bar-xyz' And here is when my colleague dropped a comment: Why don’t you use maxsplit? From the Python docs for str.split: If maxsplit is given, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). So we can just do: &gt;&gt;&gt; key.split(\"-\", maxsplit=1) ['foo', 'bar-xyz'] This ensures the first separator splits the string, and the remainder stays intact. Closing I can’t recall how many times I did the split-then-join hack when I only wanted the first split. maxsplit is the clean way to handle that."
  },

  {
    "title": "Python Neovim cheatsheet",
    "url": "/snippets/neovim-cheatsheet/",
    "date": "2025-09-28",
    "tags": ["python","neovim","tips"],
    "content": "This is the single, comprehensive guide for mastering Neovim itself and the Python‑focused setup in your init.lua. It combines fundamentals, advanced workflows, and keymaps from your configuration with clear explanations. Legend: &lt;leader&gt; is space. Modes: n = normal, t = terminal, x = visual. 1) Basics Keys / Command Description w/b/e (W/B/E) Move word/WORD forward/back/end 0/^ / $ Line start (0/^), line end ($) gg / G Go to top / bottom of file H / M / L Jump to top/middle/bottom of screen &lt;C-u&gt; / &lt;C-d&gt; Half‑page up / down &lt;C-f&gt; / &lt;C-b&gt; Page down / up % Jump between matching pairs ()[]{} /pattern / ?pattern Search forward / backward; navigate with n / N &lt;Esc&gt; Clear search highlight (mapped) &lt;C-o&gt; / &lt;C-i&gt; Jumplist back / forward &lt;C-^&gt; or :b# Switch to alternate buffer ma then 'a or `a Set and jump to mark a; special: ```` (last jump), '. (last edit) v / V / &lt;C-v&gt; Visual char / line / block mode Text objects iw/aw, i'/a', i\"/a\", i(/a(, i{/a{, ip/ap Operators + text obj e.g., ci\", da), viw Folds za toggle, zo/zc, zR/zM, zr/zm :e path Edit file (with completion) :terminal Open terminal; exit to Normal: &lt;Esc&gt;&lt;Esc&gt; (mapped) :w/:wa / :q/:qa / :wqa Write/write all; quit/quit all; write+quit all 2) Windows, Buffers, Tabs Keys / Command Description &lt;C-h&gt;, &lt;C-j&gt;, &lt;C-k&gt;, &lt;C-l&gt; Move focus left/down/up/right (mapped) :split / :vsplit Open horizontal / vertical split &lt;leader&gt;ws / &lt;leader&gt;wv Open split via mapping &lt;C-w&gt;= or &lt;leader&gt;w= Equalize split sizes :q or &lt;leader&gt;wc Close current window :only or &lt;leader&gt;wo Keep only current window :tabnew / :tabclose New / close tab &lt;leader&gt;ta / &lt;leader&gt;tc / &lt;leader&gt;to Tab new / close / only gt / gT / {N}gt Next / previous / jump to Nth tab :ls List buffers &lt;leader&gt;bn / &lt;leader&gt;bp Next / previous buffer &lt;leader&gt;bd Delete buffer &lt;leader&gt;a or :b# Alternate buffer (toggle last) &lt;leader&gt;bo Keep only current buffer (close others) Tips From Telescope, open right split: &lt;leader&gt;sf → pick → &lt;C-v&gt; Keep a “home” file on left; explore right; flip last buffer with &lt;leader&gt;a Swap windows: &lt;C-w&gt;x; lift to new tab: :tab split 3) Telescope (Files, Symbols, Search) Keys / Command Description &lt;leader&gt;sf Find files &lt;leader&gt;sh Help tags &lt;leader&gt;sk Keymaps picker &lt;leader&gt;ss Telescope builtins menu &lt;leader&gt;sw Grep word under cursor &lt;leader&gt;sg Live grep in project &lt;leader&gt;sd Diagnostics picker &lt;leader&gt;sr Resume last picker &lt;leader&gt;s. Recent files (oldfiles) &lt;leader&gt;&lt;leader&gt; Buffers list &lt;leader&gt;/ Fuzzy search in current buffer &lt;leader&gt;s/ Live grep in open files only &lt;leader&gt;sn Find files in Neovim config dir Picker controls Insert: &lt;CR&gt; open, &lt;C-x&gt; split, &lt;C-v&gt; vsplit, &lt;C-t&gt; tab, &lt;C-/&gt; show keymaps Normal (press &lt;Esc&gt;): o/&lt;CR&gt; open, s split, v vsplit, t tab, ? keymaps Multi‑open Mark with &lt;Tab&gt;, send to quickfix &lt;C-q&gt;, :copen → :cfdo tabedit % or :cfdo vsplit | wincmd l 4) LSP (Code Intelligence) Keys / Command Description grd / grD Go to definition / declaration grt Go to type definition grr References (Telescope) gri Implementations (Telescope) gO Document symbols (outline) gW Workspace symbols (project) gra Code action (also works in visual) grn Rename symbol &lt;leader&gt;th Toggle inlay hints Diagnostics Quick list: &lt;leader&gt;q (location list) Trouble: project &lt;leader&gt;xx, buffer &lt;leader&gt;xw Notes Python LSPs: Astral ty (primary), ruff (lint/format hover disabled) Use &lt;C-o&gt; back / &lt;C-i&gt; forward after jumps 5) Formatting (Conform + Ruff) Keys / Command Description &lt;leader&gt;f Format buffer (async, LSP fallback) Python ruff_fix + ruff_format configured :ConformInfo Inspect Conform settings 6) Virtualenv (venv‑selector) Keys / Command Description &lt;leader&gt;cv Choose Python venv (Telescope UI) :VenvSelect / :VenvSelectCached Select or reuse last venv Tip Prefer project .venv for consistent tooling 7) Testing (neotest + pytest) Keys / Command Description &lt;leader&gt;tn Run nearest test &lt;leader&gt;tf Run tests in current file &lt;leader&gt;ts Toggle summary panel &lt;leader&gt;to Toggle output panel &lt;leader&gt;tw Watch current file (re‑run on save) Runner pytest DAP justMyCode = false Pytest user commands (add to your init.lua) -- Run pytest with a -k pattern: :PytestPattern &lt;pattern&gt; vim.api.nvim_create_user_command('PytestPattern', function(opts) local pattern = opts.args local cmd = { 'pytest', '-k', pattern } vim.cmd('vnew') -- open a vertical split vim.fn.termopen(cmd) vim.cmd('startinsert') end, { nargs = 1, complete = 'file' }) -- Run full pytest discovery and suite: :PytestAll vim.api.nvim_create_user_command('PytestAll', function() local cmd = { 'pytest' } vim.cmd('vnew') vim.fn.termopen(cmd) vim.cmd('startinsert') end, {}) -- Optional keymaps vim.keymap.set('n', '&lt;leader&gt;tp', function() local pat = vim.fn.input('pytest -k pattern: ') if pat ~= '' then vim.cmd('PytestPattern ' .. pat) end end, { desc = 'pytest -k &lt;pattern&gt;' }) vim.keymap.set('n', '&lt;leader&gt;ta', function() vim.cmd('PytestAll') end, { desc = 'pytest (all)' }) 8) Debugging (nvim‑dap + dap‑ui + dap‑python) Keys / Command Description &lt;leader&gt;dc Continue/start (leader mapping) &lt;leader&gt;db Toggle breakpoint (leader mapping) &lt;leader&gt;do Step over (leader mapping) &lt;leader&gt;di Step into (leader mapping) &lt;leader&gt;dO Step out (leader mapping) &lt;leader&gt;du Toggle DAP UI panels &lt;leader&gt;dr Open DAP REPL Notes Python adapter: debugpy (via Mason) Uses interpreter from current venv (switch with &lt;leader&gt;cv) 9) Docstrings (neogen) Keys / Command Description &lt;leader&gt;cg Generate docstring for function/class (Google style) :Neogen Run neogen 10) Python REPL Keys / Command Description &lt;leader&gt;rp New tab REPL for current file &lt;leader&gt;rS Split REPL for current file 11) Markdown (inline rendering) Keys / Command Description &lt;leader&gt;mr Toggle inline rendering :RenderMarkdown toggle Command behind the toggle Tip: Great for reading/writing docs inside Neovim; toggle off to edit raw markup. 12) File Explorer (oil.nvim) Keys / Command Description &lt;leader&gt;e Open Oil in current working directory :Oil Open Oil in current directory :Oil . Open Oil at project/root path In Oil: &lt;CR&gt; Open file / enter directory In Oil: .. entry Go to parent directory (Optional) - mapping Open parent directory into Oil buffer g? (in Oil) Show Oil help and available actions 13) Buffer/Window/Tab Helpers Keys / Command Description &lt;leader&gt;bn / &lt;leader&gt;bp Next / previous buffer &lt;leader&gt;bd Delete current buffer &lt;leader&gt;bo Keep only current buffer &lt;leader&gt;a Alternate buffer (like :b#) &lt;leader&gt;wv / &lt;leader&gt;ws Vertical / horizontal split &lt;leader&gt;wc / &lt;leader&gt;wo Close window / keep only this window &lt;leader&gt;w= Equalize window sizes &lt;leader&gt;ta / &lt;leader&gt;tc / &lt;leader&gt;to New tab / close / only &lt;leader&gt;t1..t9 Jump to tab 1..9 gt / gT / {N}gt Native tab navigation / jump to Nth 14) Quickfix and Location Lists Keys / Command Description :copen / :cclose Open / close quickfix list :cnext / :cprev Next / previous quickfix item :cfirst / :clast First / last quickfix item :lopen / :lclose Open / close location list :lnext / :lprev Next / previous location item :lfirst / :llast First / last location item &lt;C-q&gt; (Telescope) Send selections to quickfix 15) Editing Essentials Keys / Command Description c/d/y/p/P Change/delete/yank/paste; line ops dd/yy &gt;&gt; / &lt;&lt; / = (x) Indent right / left / reindent visual gU / gu Uppercase / lowercase (e.g., gUw) J / gJ Join lines (with/without space) r{char} / R Replace single char / replace mode &lt;C-v&gt; then I/A Block insert / append q{reg} … q / @{reg} / @@ Record / play macro / repeat last macro . Repeat last change \\v Very‑magic regex mode :s/old/new/g Substitute on current line :%s/old/new/gc Substitute whole file with confirm Visual + :s/old/new/g Substitute in selection :g/pat/normal gw Run Normal cmd on all matches \"+y / \"+p System clipboard yank / paste \"_ Black‑hole register (discard) :registers View registers mA..mZ / 'A..'Z Global marks set / jump :mksession! / :source Save / load session 16) Health, Tools, Updates Keys / Command Description :checkhealth Health checks :Mason Manage external tools (ruff, ty, debugpy, etc.) :LspInfo LSP clients status :ConformInfo Conform settings :TSUpdate Update Treesitter parsers which‑key Tips menu after pressing &lt;leader&gt; 17) Quick Reference Category Highlights Global &lt;Esc&gt; clear hl; &lt;leader&gt;q diagnostics; &lt;Esc&gt;&lt;Esc&gt; (t) exit terminal; window focus &lt;C-h/j/k/l&gt; Telescope &lt;leader&gt;sf/sh/sk/ss/sw/sg/sd/sr/s./&lt;leader&gt;&lt;leader&gt;/ / s/ / sn LSP grn, gra, grr, gri, grd, grD, gO, gW, grt, &lt;leader&gt;th Formatting &lt;leader&gt;f Diagnostics (Trouble) &lt;leader&gt;xx, &lt;leader&gt;xw Venv &lt;leader&gt;cv Testing &lt;leader&gt;tn, &lt;leader&gt;tf, &lt;leader&gt;ts, &lt;leader&gt;to, &lt;leader&gt;tw, :PytestPattern, :PytestAll Debugging &lt;leader&gt;dc/db/do/di/dO, &lt;leader&gt;du, &lt;leader&gt;dr Docstrings &lt;leader&gt;cg REPL &lt;leader&gt;rp, &lt;leader&gt;rS Markdown &lt;leader&gt;mr Buffers/Windows/Tabs &lt;leader&gt;bn/bp/bd/bo/a, &lt;leader&gt;wv/ws/wc/wo/w=, &lt;leader&gt;ta/tc/to/t1..t9 Master these and you’ll navigate, refactor, test, and debug at speed — all inside Neovim."
  }

]
